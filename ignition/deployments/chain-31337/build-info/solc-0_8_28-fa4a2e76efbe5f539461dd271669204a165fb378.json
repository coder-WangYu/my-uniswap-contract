{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-fa4a2e76efbe5f539461dd271669204a165fb378",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/SwapRouter.sol": "project/contracts/SwapRouter.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "project/contracts/interfaces/IFactory.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\ninterface IFactory {\n    struct Parameters {\n        address factory;\n        address tokenA;\n        address tokenB;\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n    }\n\n    function parameters()\n        external\n        view\n        returns (\n            address factory,\n            address tokenA,\n            address tokenB,\n            int24 tickLower,\n            int24 tickUpper,\n            uint24 fee\n        );\n\n    event PoolCreated(\n        address token0,\n        address token1,\n        uint32 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint24 fee,\n        address pool\n    );\n\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint32 index\n    ) external view returns (address pool);\n\n    function createPool(\n        address tokenA,\n        address tokenB,\n        int24 tickLower,\n        int24 tickUpper,\n        uint24 fee\n    ) external returns (address pool);\n}\n"
      },
      "project/contracts/interfaces/IPool.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\ninterface IMintCallback {\n    function mintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n\ninterface ISwapCallback {\n    function swapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\ninterface IPool {\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickLower() external view returns (int24);\n    function tickUpper() external view returns (int24);\n    function sqrtPriceX96() external view returns (uint160);\n    function tick() external view returns (int24);\n    function liquidity() external view returns (uint128);\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// feeGrowthGlobal0X128 记录从创建到现在，每个流动性累计产生的 token0 的手续费\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// feeGrowthGlobal1X128 记录从创建到现在，每个流动性累计产生的 token1 的手续费\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    function getPosition(\n        address owner\n    )\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    event Mint(\n        address sender,\n        address indexed owner,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function mint(\n        address recipient,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    event Collect(\n        address indexed owner,\n        address recipient,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    function collect(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    event Burn(\n        address indexed owner,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function burn(\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n"
      },
      "project/contracts/interfaces/IPoolManager.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\npragma abicoder v2;\n\nimport \"./IFactory.sol\";\n\ninterface IPoolManager is IFactory {\n    struct PoolInfo {\n        address pool;\n        address token0;\n        address token1;\n        uint32 index;\n        uint24 fee;\n        uint8 feeProtocol;\n        int24 tickLower;\n        int24 tickUpper;\n        int24 tick;\n        uint160 sqrtPriceX96;\n        uint128 liquidity;\n    }\n\n\tstruct CreateAndInitializeParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint160 sqrtPriceX96;\n    }\n\n    struct Pair {\n        address token0;\n        address token1;\n    }\n\n    function getPairs() external view returns (Pair[] memory);\n\n    function getAllPools() external view returns (PoolInfo[] memory poolsInfo);\n\n    function createAndInitializePoolIfNecessary(\n        CreateAndInitializeParams calldata params\n    ) external payable returns (address pool);\n}"
      },
      "project/contracts/interfaces/ISwapRouter.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\npragma abicoder v2;\n\nimport \"./IPool.sol\";\n\ninterface ISwapRouter is ISwapCallback {\n    event Swap(\n        address indexed sender,\n        bool zeroForOne,\n        uint256 amountIn,\n        uint256 amountInRemaining,\n        uint256 amountOut\n    );\n\n    struct ExactInputParams {\n        address tokenIn;\n        address tokenOut;\n        uint32[] indexPath;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    struct ExactOutputParams {\n        address tokenIn;\n        address tokenOut;\n        uint32[] indexPath;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable returns (uint256 amountIn);\n\n    struct QuoteExactInputParams {\n        address tokenIn;\n        address tokenOut;\n        uint32[] indexPath;\n        uint256 amountIn;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function quoteExactInput(\n        QuoteExactInputParams calldata params\n    ) external returns (uint256 amountOut);\n\n    struct QuoteExactOutputParams {\n        address tokenIn;\n        address tokenOut;\n        uint32[] indexPath;\n        uint256 amountOut;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    function quoteExactOutput(\n        QuoteExactOutputParams calldata params\n    ) external returns (uint256 amountIn);\n}\n"
      },
      "project/contracts/SwapRouter.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\npragma abicoder v2;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./interfaces/ISwapRouter.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IPoolManager.sol\";\n\ncontract SwapRouter is ISwapRouter {\n    IPoolManager public poolManager;\n\n    constructor(address _poolManager) {\n        poolManager = IPoolManager(_poolManager);\n    }\n\n    // 解析交易失败原因的工具函数\n    function parseRevertReason(\n        bytes memory reason\n    ) private pure returns (int256, int256) {\n        if (reason.length != 64) {\n            if (reason.length < 68) revert(\"Unexpected error\");\n            assembly {\n                reason := add(reason, 0x04)\n            }\n            revert(abi.decode(reason, (string)));\n        }\n        return abi.decode(reason, (int256, int256));\n    }\n\n    function swapInPool(\n        IPool pool,\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1) {\n        try\n            pool.swap(\n                recipient,\n                zeroForOne,\n                amountSpecified,\n                sqrtPriceLimitX96,\n                data\n            )\n        returns (int256 _amount0, int256 _amount1) {\n            return (_amount0, _amount1);\n        } catch (bytes memory reason) {\n            return parseRevertReason(reason);\n        }\n    }\n\n    function exactInput(\n        ExactInputParams calldata params\n    ) external payable override returns (uint256 amountOut) {\n        // 记录确定的输入 token 的 amount\n        uint256 amountIn = params.amountIn;\n\n        // 根据 tokenIn 和 tokenOut 的大小关系，确定是从 token0 到 token1 还是从 token1 到 token0\n        bool zeroForOne = params.tokenIn < params.tokenOut;\n\n        // 遍历指定的每一个 pool\n        for (uint256 i = 0; i < params.indexPath.length; i++) {\n            address poolAddress = poolManager.getPool(\n                params.tokenIn,\n                params.tokenOut,\n                params.indexPath[i]\n            );\n\n            // 如果 pool 不存在，则抛出错误\n            require(poolAddress != address(0), \"Pool not found\");\n\n            // 获取 pool 实例\n            IPool pool = IPool(poolAddress);\n\n            // 构造 swapCallback 函数需要的参数\n            bytes memory data = abi.encode(\n                params.tokenIn,\n                params.tokenOut,\n                params.indexPath[i],\n                params.recipient == address(0) ? address(0) : msg.sender\n            );\n\n            // 调用 pool 的 swap 函数，进行交换，并拿到返回的 token0 和 token1 的数量\n            (int256 amount0, int256 amount1) = this.swapInPool(\n                pool,\n                params.recipient,\n                zeroForOne,\n                int256(amountIn),\n                params.sqrtPriceLimitX96,\n                data\n            );\n\n            // 更新 amountIn 和 amountOut\n            amountIn -= uint256(zeroForOne ? amount0 : amount1);\n            amountOut += uint256(zeroForOne ? -amount1 : -amount0);\n\n            // 如果 amountIn 为 0，表示交换完成，跳出循环\n            if (amountIn == 0) {\n                break;\n            }\n        }\n\n        // 如果交换到的 amountOut 小于指定的最少数量 amountOutMinimum，则抛出错误\n        require(amountOut >= params.amountOutMinimum, \"Slippage exceeded\");\n\n        // 发送 Swap 事件\n        emit Swap(msg.sender, zeroForOne, params.amountIn, amountIn, amountOut);\n\n        // 返回 amountOut\n        return amountOut;\n    }\n\n    function exactOutput(\n        ExactOutputParams calldata params\n    ) external payable override returns (uint256 amountIn) {\n        // 记录确定的输出 token 的 amount\n        uint256 amountOut = params.amountOut;\n\n        // 根据 tokenIn 和 tokenOut 的大小关系，确定是从 token0 到 token1 还是从 token1 到 token0\n        bool zeroForOne = params.tokenIn < params.tokenOut;\n\n        // 遍历指定的每一个 pool\n        for (uint256 i = 0; i < params.indexPath.length; i++) {\n            address poolAddress = poolManager.getPool(\n                params.tokenIn,\n                params.tokenOut,\n                params.indexPath[i]\n            );\n\n            // 如果 pool 不存在，则抛出错误\n            require(poolAddress != address(0), \"Pool not found\");\n\n            // 获取 pool 实例\n            IPool pool = IPool(poolAddress);\n\n            // 构造 swapCallback 函数需要的参数\n            bytes memory data = abi.encode(\n                params.tokenIn,\n                params.tokenOut,\n                params.indexPath[i],\n                params.recipient == address(0) ? address(0) : msg.sender\n            );\n\n            // 调用 pool 的 swap 函数，进行交换，并拿到返回的 token0 和 token1 的数量\n            (int256 amount0, int256 amount1) = this.swapInPool(\n                pool,\n                params.recipient,\n                zeroForOne,\n                -int256(amountOut),\n                params.sqrtPriceLimitX96,\n                data\n            );\n\n            // 更新 amountOut 和 amountIn\n            amountOut -= uint256(zeroForOne ? -amount1 : -amount0);\n            amountIn += uint256(zeroForOne ? amount0 : amount1);\n\n            // 如果 amountOut 为 0，表示交换完成，跳出循环\n            if (amountOut == 0) {\n                break;\n            }\n        }\n\n        // 如果交换到指定数量 tokenOut 消耗的 tokenIn 数量超过指定的最大值，报错\n        require(amountIn <= params.amountInMaximum, \"Slippage exceeded\");\n\n        // 发射 Swap 事件\n        emit Swap(\n            msg.sender,\n            zeroForOne,\n            params.amountOut,\n            amountOut,\n            amountIn\n        );\n\n        // 返回交换后的 amountIn\n        return amountIn;\n    }\n\n    // 报价，指定 tokenIn 的数量和 tokenOut 的最小值，返回 tokenOut 的实际数量\n    function quoteExactInput(\n        QuoteExactInputParams calldata params\n    ) external override returns (uint256 amountOut) {\n        // 因为没有实际 approve，所以这里交易会报错，我们捕获错误信息，解析需要多少 token\n\n        return\n            this.exactInput(\n                ExactInputParams({\n                    tokenIn: params.tokenIn,\n                    tokenOut: params.tokenOut,\n                    indexPath: params.indexPath,\n                    recipient: address(0),\n                    deadline: block.timestamp + 1 hours,\n                    amountIn: params.amountIn,\n                    amountOutMinimum: 0,\n                    sqrtPriceLimitX96: params.sqrtPriceLimitX96\n                })\n            );\n    }\n\n    // 报价，指定 tokenOut 的数量和 tokenIn 的最大值，返回 tokenIn 的实际数量\n    function quoteExactOutput(\n        QuoteExactOutputParams calldata params\n    ) external override returns (uint256 amountIn) {\n        return\n            this.exactOutput(\n                ExactOutputParams({\n                    tokenIn: params.tokenIn,\n                    tokenOut: params.tokenOut,\n                    indexPath: params.indexPath,\n                    recipient: address(0),\n                    deadline: block.timestamp + 1 hours,\n                    amountOut: params.amountOut,\n                    amountInMaximum: type(uint256).max,\n                    sqrtPriceLimitX96: params.sqrtPriceLimitX96\n                })\n            );\n    }\n\n    function swapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external override {\n        // transfer token\n        (address tokenIn, address tokenOut, uint32 index, address payer) = abi\n            .decode(data, (address, address, uint32, address));\n        address _pool = poolManager.getPool(tokenIn, tokenOut, index);\n\n        // 检查 callback 的合约地址是否是 Pool\n        require(_pool == msg.sender, \"Invalid callback caller\");\n\n        uint256 amountToPay = amount0Delta > 0\n            ? uint256(amount0Delta)\n            : uint256(amount1Delta);\n        // payer 是 address(0)，这是一个用于预估 token 的请求（quoteExactInput or quoteExactOutput）\n        // 参考代码 https://github.com/Uniswap/v3-periphery/blob/main/contracts/lens/Quoter.sol#L38\n        if (payer == address(0)) {\n            assembly { // 内联汇编关键字，用于在Solidity代码中直接编写EVM字节码，直接操作以太坊虚拟机的底层指令\n                let ptr := mload(0x40) // 获取空闲内存指针\n                mstore(ptr, amount0Delta) // 将 amount0Delta 存储到 ptr 指向的内存位置\n                mstore(add(ptr, 0x20), amount1Delta) // 将 amount1Delta 存储到 ptr + 0x20 指向的内存位置\n                revert(ptr, 64) // 终止当前函数执行，并返回指定长度的数据\n            }\n        }\n\n        // 正常交易，转账给交易池\n        if (amountToPay > 0) {\n            IERC20(tokenIn).transferFrom(payer, _pool, amountToPay);\n        }\n    }\n}\n"
      }
    }
  }
}