{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-50bc1bb98e1255823da92352d80cbc0e6d010e0f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PoolManager.sol": "project/contracts/PoolManager.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/token/ERC20/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
      },
      "project/contracts/Factory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8;\n\nimport \"./interfaces/IFactory.sol\";\nimport \"./Pool.sol\";\n\ncontract Factory is IFactory {\n\t// tokenA => tokenB => [pool1, pool2, pool3, ...]\n    mapping(address => mapping(address => address[])) public pools;\n\n\tParameters public override parameters;\n\n    modifier differentTokens(address tokenA, address tokenB) {\n        require(tokenA != tokenB, \"TokenA and TokenB cannot be the same\");\n        _;\n    }\n\n    function sortToken(\n        address tokenA,\n        address tokenB\n    ) private pure returns (address, address) {\n        return (tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA));\n    }\n\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint32 index\n    ) external view override differentTokens(tokenA, tokenB) returns (address) {\n\t\trequire(tokenA != address(0) && tokenB != address(0), \"TokenA and TokenB cannot be the zero address\");\n\n        address token0;\n        address token1;\n        (token0, token1) = sortToken(tokenA, tokenB);\n\n        return pools[token0][token1][index];\n    }\n\n\tfunction createPool(\n\t\taddress tokenA,\n\t\taddress tokenB,\n\t\tint24 tickLower,\n\t\tint24 tickUpper,\n\t\tuint24 fee\n\t) external override differentTokens(tokenA, tokenB) returns (address pool) {\n\t\taddress token0;\n\t\taddress token1;\n\n\t\t(token0, token1) = sortToken(tokenA, tokenB);\n\n\t\taddress[] memory existingPools = pools[token0][token1];\n\n\t\tfor (uint i = 0; i < existingPools.length; i++) {\n\t\t\tIPool currentPool = IPool(existingPools[i]);\n\t\t\t\n\t\t\tif (currentPool.tickLower() == tickLower && \n\t\t\t\tcurrentPool.tickUpper() == tickUpper && \n\t\t\t\tcurrentPool.fee() == fee\n\t\t\t) {\n\t\t\t\treturn existingPools[i];\n\t\t\t}\n\t\t}\n\n\t\tparameters = Parameters(\n\t\t\taddress(this),\n\t\t\ttoken0,\n\t\t\ttoken1,\n\t\t\ttickLower,\n\t\t\ttickUpper,\n\t\t\tfee\n\t\t);\n\n\t\tbytes32 salt = keccak256(\n\t\t\tabi.encode(token0, token1, tickLower, tickUpper, fee)\n\t\t);\n\n\t\tpool = address(new Pool{salt: salt}());\n\n\t\tpools[token0][token1].push(pool);\n\n\t\tdelete parameters; // 删除parameters，释放内存\n\n\t\temit PoolCreated(\n            token0,\n            token1,\n            uint32(existingPools.length),\n            tickLower,\n            tickUpper,\n            fee,\n            pool\n        );\n\t}\n}\n"
      },
      "project/contracts/interfaces/IFactory.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\ninterface IFactory {\n    struct Parameters {\n        address factory;\n        address tokenA;\n        address tokenB;\n        int24 tickLower;\n        int24 tickUpper;\n        uint24 fee;\n    }\n\n    function parameters()\n        external\n        view\n        returns (\n            address factory,\n            address tokenA,\n            address tokenB,\n            int24 tickLower,\n            int24 tickUpper,\n            uint24 fee\n        );\n\n    event PoolCreated(\n        address token0,\n        address token1,\n        uint32 index,\n        int24 tickLower,\n        int24 tickUpper,\n        uint24 fee,\n        address pool\n    );\n\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint32 index\n    ) external view returns (address pool);\n\n    function createPool(\n        address tokenA,\n        address tokenB,\n        int24 tickLower,\n        int24 tickUpper,\n        uint24 fee\n    ) external returns (address pool);\n}\n"
      },
      "project/contracts/interfaces/IPool.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\n\ninterface IMintCallback {\n    function mintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n\ninterface ISwapCallback {\n    function swapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n\ninterface IPool {\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function fee() external view returns (uint24);\n    function tickLower() external view returns (int24);\n    function tickUpper() external view returns (int24);\n    function sqrtPriceX96() external view returns (uint160);\n    function tick() external view returns (int24);\n    function liquidity() external view returns (uint128);\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// feeGrowthGlobal0X128 记录从创建到现在，每个流动性累计产生的 token0 的手续费\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// feeGrowthGlobal1X128 记录从创建到现在，每个流动性累计产生的 token1 的手续费\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    function getPosition(\n        address owner\n    )\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    event Mint(\n        address sender,\n        address indexed owner,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function mint(\n        address recipient,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    event Collect(\n        address indexed owner,\n        address recipient,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    function collect(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    event Burn(\n        address indexed owner,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    function burn(\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n}\n"
      },
      "project/contracts/interfaces/IPoolManager.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.24;\npragma abicoder v2;\n\nimport \"./IFactory.sol\";\n\ninterface IPoolManager is IFactory {\n    struct PoolInfo {\n        address pool;\n        address token0;\n        address token1;\n        uint32 index;\n        uint24 fee;\n        uint8 feeProtocol;\n        int24 tickLower;\n        int24 tickUpper;\n        int24 tick;\n        uint160 sqrtPriceX96;\n        uint128 liquidity;\n    }\n\n\tstruct CreateAndInitializeParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint160 sqrtPriceX96;\n    }\n\n    struct Pair {\n        address token0;\n        address token1;\n    }\n\n    function getPairs() external view returns (Pair[] memory);\n\n    function getAllPools() external view returns (PoolInfo[] memory poolsInfo);\n\n    function createAndInitializePoolIfNecessary(\n        CreateAndInitializeParams calldata params\n    ) external payable returns (address pool);\n}"
      },
      "project/contracts/libraries/BitMath.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(\n                r,\n                byte(\n                    and(\n                        0x1f,\n                        shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)\n                    ),\n                    0x0706060506020500060203020504000106050205030304010505030400000000\n                )\n            )\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(\n                5,\n                shr(\n                    252,\n                    shl(\n                        shl(\n                            2,\n                            shr(\n                                250,\n                                mul(\n                                    x,\n                                    0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff\n                                )\n                            )\n                        ),\n                        0x8040405543005266443200005020610674053026020000107506200176117077\n                    )\n                )\n            )\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(\n                r,\n                byte(\n                    and(div(0xd76453e0, shr(r, x)), 0x1f),\n                    0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405\n                )\n            )\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/CustomRevert.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(\n        bytes4 selector,\n        int24 value1,\n        int24 value2\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(\n        bytes4 selector,\n        uint160 value1,\n        uint160 value2\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(\n                add(fmp, 0x04),\n                and(value1, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(fmp, 0x24),\n                and(value2, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(\n        bytes4 selector,\n        address value1,\n        address value2\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(\n                add(fmp, 0x04),\n                and(value1, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(fmp, 0x24),\n                and(value2, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with the selector provided\n    /// @dev this function should only be used with custom errors of the type `CustomError(address target, bytes revertReason)`\n    function bubbleUpAndRevertWith(\n        bytes4 selector,\n        address addr\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let size := returndatasize()\n            let fmp := mload(0x40)\n\n            // Encode selector, address, offset, size, data\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), addr)\n            mstore(add(fmp, 0x24), 0x40)\n            mstore(add(fmp, 0x44), size)\n            returndatacopy(add(fmp, 0x64), 0, size)\n\n            // Ensure the size is a multiple of 32 bytes\n            let encodedSize := add(0x64, mul(div(add(size, 31), 32), 32))\n            revert(fmp, encodedSize)\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/FixedPoint128.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
      },
      "project/contracts/libraries/FixedPoint96.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
      },
      "project/contracts/libraries/FullMath.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly (\"memory-safe\") {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly (\"memory-safe\") {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly (\"memory-safe\") {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly (\"memory-safe\") {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly (\"memory-safe\") {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly (\"memory-safe\") {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) != 0) {\n                require(++result > 0);\n            }\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/LiquidityMath.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/LowGasSafeMath.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
      },
      "project/contracts/libraries/SafeCast.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2 ** 255);\n        z = int256(y);\n    }\n}\n"
      },
      "project/contracts/libraries/SqrtPriceMath.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./LowGasSafeMath.sol\";\nimport \"./SafeCast.sol\";\n\nimport \"./FullMath.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            uint256 product;\n            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                uint256 denominator = numerator1 + product;\n                if (denominator >= numerator1)\n                    // always fits in 160 bits\n                    return\n                        uint160(\n                            FullMath.mulDivRoundingUp(\n                                numerator1,\n                                sqrtPX96,\n                                denominator\n                            )\n                        );\n            }\n\n            return\n                uint160(\n                    UnsafeMath.divRoundingUp(\n                        numerator1,\n                        (numerator1 / sqrtPX96).add(amount)\n                    )\n                );\n        } else {\n            uint256 product;\n            // if the product overflows, we know the denominator underflows\n            // in addition, we must check that the denominator does not underflow\n            require(\n                (product = amount * sqrtPX96) / amount == sqrtPX96 &&\n                    numerator1 > product\n            );\n            uint256 denominator = numerator1 - product;\n            return\n                FullMath\n                    .mulDivRoundingUp(numerator1, sqrtPX96, denominator)\n                    .toUint160();\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return uint256(sqrtPX96).add(quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(\n                        amount << FixedPoint96.RESOLUTION,\n                        liquidity\n                    )\n                    : FullMath.mulDivRoundingUp(\n                        amount,\n                        FixedPoint96.Q96,\n                        liquidity\n                    )\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(\n                    sqrtPX96,\n                    liquidity,\n                    amountIn,\n                    true\n                )\n                : getNextSqrtPriceFromAmount1RoundingDown(\n                    sqrtPX96,\n                    liquidity,\n                    amountIn,\n                    true\n                );\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(\n                    sqrtPX96,\n                    liquidity,\n                    amountOut,\n                    false\n                )\n                : getNextSqrtPriceFromAmount0RoundingUp(\n                    sqrtPX96,\n                    liquidity,\n                    amountOut,\n                    false\n                );\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n        require(sqrtRatioAX96 > 0);\n\n        return\n            roundUp\n                ? UnsafeMath.divRoundingUp(\n                    FullMath.mulDivRoundingUp(\n                        numerator1,\n                        numerator2,\n                        sqrtRatioBX96\n                    ),\n                    sqrtRatioAX96\n                )\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) /\n                    sqrtRatioAX96;\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            roundUp\n                ? FullMath.mulDivRoundingUp(\n                    liquidity,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    FixedPoint96.Q96\n                )\n                : FullMath.mulDiv(\n                    liquidity,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    FixedPoint96.Q96\n                );\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        return\n            liquidity < 0\n                ? -getAmount0Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(-liquidity),\n                    false\n                ).toInt256()\n                : getAmount0Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(liquidity),\n                    true\n                ).toInt256();\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        return\n            liquidity < 0\n                ? -getAmount1Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(-liquidity),\n                    false\n                ).toInt256()\n                : getAmount1Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(liquidity),\n                    true\n                ).toInt256();\n    }\n}\n"
      },
      "project/contracts/libraries/SwapMath.sol": {
        "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./FullMath.sol\";\nimport \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    )\n        internal\n        pure\n        returns (\n            uint160 sqrtRatioNextX96,\n            uint256 amountIn,\n            uint256 amountOut,\n            uint256 feeAmount\n        )\n    {\n        bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n        bool exactIn = amountRemaining >= 0;\n\n        if (exactIn) {\n            uint256 amountRemainingLessFee = FullMath.mulDiv(\n                uint256(amountRemaining),\n                1e6 - feePips,\n                1e6\n            );\n            amountIn = zeroForOne\n                ? SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioTargetX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    true\n                )\n                : SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioTargetX96,\n                    liquidity,\n                    true\n                );\n            if (amountRemainingLessFee >= amountIn)\n                sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    amountRemainingLessFee,\n                    zeroForOne\n                );\n        } else {\n            amountOut = zeroForOne\n                ? SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioTargetX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    false\n                )\n                : SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioTargetX96,\n                    liquidity,\n                    false\n                );\n            if (uint256(-amountRemaining) >= amountOut)\n                sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    uint256(-amountRemaining),\n                    zeroForOne\n                );\n        }\n\n        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n        // get the input/output amounts\n        if (zeroForOne) {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioNextX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    true\n                );\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioNextX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    false\n                );\n        } else {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioNextX96,\n                    liquidity,\n                    true\n                );\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioNextX96,\n                    liquidity,\n                    false\n                );\n        }\n\n        // cap the output amount to not exceed the remaining output amount\n        if (!exactIn && amountOut > uint256(-amountRemaining)) {\n            amountOut = uint256(-amountRemaining);\n        }\n\n        if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n            // we didn't reach the target, so take the remainder of the maximum input as fee\n            feeAmount = uint256(amountRemaining) - amountIn;\n        } else {\n            feeAmount = FullMath.mulDivRoundingUp(\n                amountIn,\n                feePips,\n                1e6 - feePips\n            );\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/TickMath.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE =\n        1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(\n        int24 tick\n    ) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK)))\n                InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(\n                    shl(128, 1),\n                    mul(\n                        xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001),\n                        and(absTick, 0x1)\n                    )\n                )\n            }\n            if (absTick & 0x2 != 0)\n                price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0)\n                price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0)\n                price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0)\n                price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0)\n                price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0)\n                price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0)\n                price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0)\n                price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0)\n                price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0)\n                price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0)\n                price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0)\n                price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0)\n                price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0)\n                price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0)\n                price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0)\n                price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0)\n                price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0)\n                price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0)\n                price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) {\n                    price := div(not(0), price)\n                }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(\n        uint160 sqrtPriceX96\n    ) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if (\n                (sqrtPriceX96 - MIN_SQRT_PRICE) >\n                MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE\n            ) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24(\n                (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n            );\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24(\n                (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n            );\n\n            tick = tickLow == tickHi\n                ? tickLow\n                : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96\n                ? tickHi\n                : tickLow;\n        }\n    }\n}\n"
      },
      "project/contracts/libraries/TransferHelper.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\nlibrary TransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Calls transfer on token contract, errors with TF if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TF\"\n        );\n    }\n}\n"
      },
      "project/contracts/libraries/UnsafeMath.sol": {
        "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
      },
      "project/contracts/Pool.sol": {
        "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./libraries/SqrtPriceMath.sol\";\nimport \"./libraries/TickMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/LowGasSafeMath.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/SwapMath.sol\";\nimport \"./libraries/FixedPoint128.sol\";\n\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IFactory.sol\";\n\ncontract Pool is IPool {\n    // using ... for ：用于为特定类型添加库函数\n    using SafeCast for uint256;\n    using LowGasSafeMath for int256;\n    using LowGasSafeMath for uint256;\n\n    address public immutable override factory;\n    address public immutable override token0;\n    address public immutable override token1;\n    uint24 public immutable override fee;\n    int24 public immutable override tickLower;\n    int24 public immutable override tickUpper;\n\n    uint160 public override sqrtPriceX96; // 表示token0/token1的当前价格\n    int24 public override tick;\n    uint128 public override liquidity; // 表示当前池子中的流动性总量：K = x * y，恒定乘积公式\n    uint256 public override feeGrowthGlobal0X128;\n    uint256 public override feeGrowthGlobal1X128;\n\n\t// 交易中需要临时存储的变量\n    struct SwapState {\n        int256 amountSpecifiedRemaining; // 用于跟踪交易过程中剩余交换量，跟踪交易进度，确保完成指定的交换量\n        int256 amountCalculated; // 用于跟踪已经计算出的交换量，累计记录交易过程中已经确定的交换量\n        uint160 sqrtPriceX96;\n        uint256 feeGrowthGlobalX128;\n        uint256 amountIn; // 该交易中用户转入的 token0 的数量\n        uint256 amountOut; // 该交易中用户转出的 token1 的数量\n        uint256 feeAmount; // 该交易中的手续费，如果 zeroForOne 是 ture，则是用户转入 token0，单位是 token0 的数量，反正是 token1 的数量\n    }\n\n    struct Position {\n        uint128 liquidity; // 该 Position 拥有的流动性\n        uint128 tokensOwed0; // 可提取的 token0 数量\n        uint128 tokensOwed1; // 可提取的 token1 数量\n        uint256 feeGrowthInside0LastX128; // 上次提取手续费时的 feeGrowthGlobal0X128\n        uint256 feeGrowthInside1LastX128; // 上次提取手续费时的 feeGrowthGlobal1X128\n    }\n\n    struct ModifyPositionParams {\n        address owner;\n        int128 liquidityDelta;\n    }\n\n    // 用一个 mapping 来存放所有 Position 的信息\n    mapping(address => Position) public positions;\n\n    constructor() {\n        (factory, token0, token1, tickLower, tickUpper, fee) = IFactory(\n            msg.sender\n        ).parameters(); // 相当于包装类，将msg.sender包装成IFactory接口类型，然后调用IFactory接口的parameters方法\n    }\n\n    function getPosition(\n        address owner\n    )\n        external\n        view\n        override\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        )\n    {\n        return (\n            positions[owner].liquidity,\n            positions[owner].feeGrowthInside0LastX128,\n            positions[owner].feeGrowthInside1LastX128,\n            positions[owner].tokensOwed0,\n            positions[owner].tokensOwed1\n        );\n    }\n\n    function initialize(uint160 sqrtPriceX96_) external override {\n        require(sqrtPriceX96 == 0, \"INITIALIZED\");\n        // 通过价格获取 tick，判断 tick 是否在 tickLower 和 tickUpper 之间\n        tick = TickMath.getTickAtSqrtPrice(sqrtPriceX96_);\n        require(\n            tick >= tickLower && tick < tickUpper,\n            \"sqrtPriceX96 should be within the range of [tickLower, tickUpper)\"\n        );\n        // 初始化 Pool 的 sqrtPriceX96\n        sqrtPriceX96 = sqrtPriceX96_;\n    }\n\n    function _modifyPosition(\n        ModifyPositionParams memory params\n    ) private returns (int256 amount0, int256 amount1) {\n        // 通过新增的流动性计算 amount0 和 amount1\n        // 参考 UniswapV3 的代码\n\n        amount0 = SqrtPriceMath.getAmount0Delta(\n            sqrtPriceX96,\n            TickMath.getSqrtPriceAtTick(tickUpper),\n            params.liquidityDelta\n        );\n\n        amount1 = SqrtPriceMath.getAmount1Delta(\n            TickMath.getSqrtPriceAtTick(tickLower),\n            sqrtPriceX96,\n            params.liquidityDelta\n        );\n        Position storage position = positions[params.owner];\n\n        // 提取手续费，计算从上一次提取到当前的手续费\n        uint128 tokensOwed0 = uint128(\n            FullMath.mulDiv(\n                feeGrowthGlobal0X128 - position.feeGrowthInside0LastX128,\n                position.liquidity,\n                FixedPoint128.Q128\n            )\n        );\n        uint128 tokensOwed1 = uint128(\n            FullMath.mulDiv(\n                feeGrowthGlobal1X128 - position.feeGrowthInside1LastX128,\n                position.liquidity,\n                FixedPoint128.Q128\n            )\n        );\n\n        // 更新提取手续费的记录，同步到当前最新的 feeGrowthGlobal0X128，代表都提取完了\n        position.feeGrowthInside0LastX128 = feeGrowthGlobal0X128;\n        position.feeGrowthInside1LastX128 = feeGrowthGlobal1X128;\n        // 把可以提取的手续费记录到 tokensOwed0 和 tokensOwed1 中\n        // LP 可以通过 collect 来最终提取到用户自己账户上\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\n            position.tokensOwed0 += tokensOwed0;\n            position.tokensOwed1 += tokensOwed1;\n        }\n\n        // 修改 liquidity\n        liquidity = LiquidityMath.addDelta(liquidity, params.liquidityDelta);\n        position.liquidity = LiquidityMath.addDelta(\n            position.liquidity,\n            params.liquidityDelta\n        );\n    }\n\n    // 获取token0余额\n    function balance0() private view returns (uint256) {\n        (bool success, bytes memory data) = token0.staticcall( // 只读的，无法修改状态，防止重入攻击\n                abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)) // 编码函数选择器\n            );\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256)); // 返回解码后的token0的余额\n    }\n\n    // 获取token1余额\n    function balance1() private view returns (uint256) {\n        (bool success, bytes memory data) = token1.staticcall(\n            abi.encodeWithSelector(IERC20.balanceOf.selector, address(this))\n        );\n        require(success && data.length >= 32);\n        return abi.decode(data, (uint256));\n    }\n\n\t// 添加流动性\n    function mint(\n        address recipient,\n        uint128 amount,\n        bytes calldata data\n    ) external override returns (uint256 amount0, uint256 amount1) {\n        require(amount > 0, \"Mint amount must be greater than 0\");\n        // 基于 amount 计算出当前需要多少 amount0 和 amount1\n        (int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: recipient,\n                liquidityDelta: int128(amount)\n            })\n        );\n        amount0 = uint256(amount0Int);\n        amount1 = uint256(amount1Int);\n\n        uint256 balance0Before;\n        uint256 balance1Before;\n        if (amount0 > 0) balance0Before = balance0();\n        if (amount1 > 0) balance1Before = balance1();\n        // 回调 mintCallback\n        IMintCallback(msg.sender).mintCallback(amount0, amount1, data);\n\n        if (amount0 > 0)\n            require(balance0Before.add(amount0) <= balance0(), \"M0\");\n        if (amount1 > 0)\n            require(balance1Before.add(amount1) <= balance1(), \"M1\");\n\n        emit Mint(msg.sender, recipient, amount, amount0, amount1);\n    }\n\n\t// 移除流动性\n\tfunction burn(\n        uint128 amount\n    ) external override returns (uint256 amount0, uint256 amount1) {\n        require(amount > 0, \"Burn amount must be greater than 0\");\n        require(\n            amount <= positions[msg.sender].liquidity,\n            \"Burn amount exceeds liquidity\"\n        );\n        // 修改 positions 中的信息\n        (int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: msg.sender,\n                liquidityDelta: -int128(amount)\n            })\n        );\n        // 获取燃烧后的 amount0 和 amount1\n        amount0 = uint256(-amount0Int);\n        amount1 = uint256(-amount1Int);\n\n        if (amount0 > 0 || amount1 > 0) {\n            (\n                positions[msg.sender].tokensOwed0,\n                positions[msg.sender].tokensOwed1\n            ) = (\n                positions[msg.sender].tokensOwed0 + uint128(amount0),\n                positions[msg.sender].tokensOwed1 + uint128(amount1)\n            );\n        }\n\n        emit Burn(msg.sender, amount, amount0, amount1);\n    }\n\n\t// 提取token\n\tfunction collect(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external override returns (uint128 amount0, uint128 amount1) {\n        // 获取当前用户的 position\n        Position storage position = positions[msg.sender];\n\n        // 把钱退给用户 recipient\n        amount0 = amount0Requested > position.tokensOwed0\n            ? position.tokensOwed0\n            : amount0Requested;\n        amount1 = amount1Requested > position.tokensOwed1\n            ? position.tokensOwed1\n            : amount1Requested;\n\n        if (amount0 > 0) {\n            position.tokensOwed0 -= amount0;\n            TransferHelper.safeTransfer(token0, recipient, amount0);\n        }\n        if (amount1 > 0) {\n            position.tokensOwed1 -= amount1;\n            TransferHelper.safeTransfer(token1, recipient, amount1);\n        }\n\n        emit Collect(msg.sender, recipient, amount0, amount1);\n    }\n\n\tfunction swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external override returns (int256 amount0, int256 amount1) {\n        require(amountSpecified != 0, \"AS\");\n\n        // zeroForOne: 如果从 token0 交换 token1 则为 true，从 token1 交换 token0 则为 false\n        // 判断当前价格是否满足交易的条件\n        require(\n            zeroForOne\n                ? sqrtPriceLimitX96 < sqrtPriceX96 &&\n                    sqrtPriceLimitX96 > TickMath.MIN_SQRT_PRICE\n                : sqrtPriceLimitX96 > sqrtPriceX96 &&\n                    sqrtPriceLimitX96 < TickMath.MAX_SQRT_PRICE,\n            \"SPL\"\n        );\n\n        // amountSpecified 大于 0 代表用户指定了 token0 的数量，小于 0 代表用户指定了 token1 的数量\n        bool exactInput = amountSpecified > 0;\n\n        SwapState memory state = SwapState({\n            amountSpecifiedRemaining: amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: sqrtPriceX96,\n            feeGrowthGlobalX128: zeroForOne\n                ? feeGrowthGlobal0X128\n                : feeGrowthGlobal1X128,\n            amountIn: 0,\n            amountOut: 0,\n            feeAmount: 0\n        });\n\n        // 计算交易的上下限，基于 tick 计算价格\n        uint160 sqrtPriceX96Lower = TickMath.getSqrtPriceAtTick(tickLower);\n        uint160 sqrtPriceX96Upper = TickMath.getSqrtPriceAtTick(tickUpper);\n        // 计算用户交易价格的限制，如果是 zeroForOne 是 true，说明用户会换入 token0，会压低 token0 的价格（也就是池子的价格），所以要限制最低价格不能超过 sqrtPriceX96Lower\n        uint160 sqrtPriceX96PoolLimit = zeroForOne\n            ? sqrtPriceX96Lower\n            : sqrtPriceX96Upper;\n\n        // 计算交易的具体数值\n        (\n            state.sqrtPriceX96,\n            state.amountIn,\n            state.amountOut,\n            state.feeAmount\n        ) = SwapMath.computeSwapStep(\n            sqrtPriceX96,\n            (\n                zeroForOne\n                    ? sqrtPriceX96PoolLimit < sqrtPriceLimitX96\n                    : sqrtPriceX96PoolLimit > sqrtPriceLimitX96\n            )\n                ? sqrtPriceLimitX96\n                : sqrtPriceX96PoolLimit,\n            liquidity,\n            amountSpecified,\n            fee\n        );\n\n        // 更新新的价格\n        sqrtPriceX96 = state.sqrtPriceX96;\n        tick = TickMath.getTickAtSqrtPrice(state.sqrtPriceX96);\n\n        // 计算手续费\n        state.feeGrowthGlobalX128 += FullMath.mulDiv(\n            state.feeAmount,\n            FixedPoint128.Q128,\n            liquidity\n        );\n\n        // 更新手续费相关信息\n        if (zeroForOne) {\n            feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n        } else {\n            feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n        }\n\n        // 计算交易后用户手里的 token0 和 token1 的数量\n        if (exactInput) {\n            state.amountSpecifiedRemaining -= (state.amountIn + state.feeAmount)\n                .toInt256();\n            state.amountCalculated = state.amountCalculated.sub(\n                state.amountOut.toInt256()\n            );\n        } else {\n            state.amountSpecifiedRemaining += state.amountOut.toInt256();\n            state.amountCalculated = state.amountCalculated.add(\n                (state.amountIn + state.feeAmount).toInt256()\n            );\n        }\n\n        (amount0, amount1) = zeroForOne == exactInput\n            ? (\n                amountSpecified - state.amountSpecifiedRemaining,\n                state.amountCalculated\n            )\n            : (\n                state.amountCalculated,\n                amountSpecified - state.amountSpecifiedRemaining\n            );\n\n        if (zeroForOne) {\n            // callback 中需要给 Pool 转入 token0\n            uint256 balance0Before = balance0();\n            ISwapCallback(msg.sender).swapCallback(amount0, amount1, data);\n            require(balance0Before.add(uint256(amount0)) <= balance0(), \"IIA\");\n\n            // 转 Token 给用户\n            if (amount1 < 0)\n                TransferHelper.safeTransfer(\n                    token1,\n                    recipient,\n                    uint256(-amount1)\n                );\n        } else {\n            // callback 中需要给 Pool 转入 token1\n            uint256 balance1Before = balance1();\n            ISwapCallback(msg.sender).swapCallback(amount0, amount1, data);\n            require(balance1Before.add(uint256(amount1)) <= balance1(), \"IIA\");\n\n            // 转 Token 给用户\n            if (amount0 < 0)\n                TransferHelper.safeTransfer(\n                    token0,\n                    recipient,\n                    uint256(-amount0)\n                );\n        }\n\n        emit Swap(\n            msg.sender,\n            recipient,\n            amount0,\n            amount1,\n            sqrtPriceX96,\n            liquidity,\n            tick\n        );\n    }\n}\n"
      },
      "project/contracts/PoolManager.sol": {
        "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8;\n\nimport \"./Factory.sol\";\nimport \"./interfaces/IPool.sol\";\nimport \"./interfaces/IPoolManager.sol\";\n\ncontract PoolManager is Factory, IPoolManager {\n    Pair[] public pairs; // 存储币对，默认提供的getter方法需要传入index，仅能获取某个成员，所以需要getPairs方法返回整个数组\n    function getPairs() external view override returns (Pair[] memory) {\n        return pairs;\n    }\n\n    function getAllPools()\n        external\n        view\n        override\n        returns (PoolInfo[] memory poolsInfo)\n    {\n        // 获得所有流动池pool的数量\n        uint32 length = 0;\n        for (uint i = 0; i < pairs.length; i++) {\n            length += uint32(pools[pairs[i].token0][pairs[i].token1].length); // pools继承于Factory合约\n        }\n\n        // 填充每个流动池pool的数据\n        poolsInfo = new PoolInfo[](length); // 创建长度为length的PoolInfop[]\n        uint index = 0; // 记录当前插入的位置\n\n        for (uint i = 0; i < pairs.length; i++) {\n            address[] memory poolsAddress = pools[pairs[i].token0][\n                pairs[i].token1\n            ]; // [pool1, pool2, pool3, ...]\n\n            for (uint j = 0; j < poolsAddress.length; j++) {\n                IPool pool = IPool(poolsAddress[j]);\n\n                poolsInfo[index] = PoolInfo({\n                    pool: poolsAddress[j],\n                    token0: pool.token0(),\n                    token1: pool.token1(),\n                    index: uint32(j),\n                    fee: pool.fee(),\n                    feeProtocol: 0,\n                    tickLower: pool.tickLower(),\n                    tickUpper: pool.tickUpper(),\n                    tick: pool.tick(),\n                    sqrtPriceX96: pool.sqrtPriceX96(),\n                    liquidity: pool.liquidity()\n                });\n\n                index++;\n            }\n        }\n\n        return poolsInfo;\n    }\n\n\t// 调试和初始化参数\n    function createAndInitializePoolIfNecessary(\n        CreateAndInitializeParams calldata params\n    ) external payable override returns (address poolAddress) {\n        require(params.token0 < params.token1, \"token0 must be less than token1\");\n\n        poolAddress = this.createPool(\n            params.token0,\n            params.token1,\n            params.tickLower,\n            params.tickUpper,\n            params.fee\n        );\n\n        IPool pool = IPool(poolAddress);\n\n        uint256 index = pools[pool.token0()][pool.token1()].length;\n\n        // 新创建的池子，没有初始化价格，需要初始化价格\n        if (pool.sqrtPriceX96() == 0) {\n            pool.initialize(params.sqrtPriceX96);\n\n            if (index == 1) {\n                // 如果是第一次添加该交易对，需要记录\n                pairs.push(\n                    Pair({token0: pool.token0(), token1: pool.token1()})\n                );\n            }\n        }\n    }\n}\n"
      }
    }
  }
}